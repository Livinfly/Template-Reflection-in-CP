>   学习知识点时遇到比较好的博客文章，记录一下。
>
>   然后这些文章里面又有对其作者启发的文章也建议看看。
>
>   我只是记录了我自己看了比较有启发的文章。

[Library Checker](https://judge.yosupo.jp/) - 验板子的地方（大概）



## 图论

### 图的匹配

[从匈牙利算法到带权带花树——详解对偶问题在图匹配上的应用 | Potassium's blog](https://potassiumwings.github.io/2021/09/10/from_hungary_to_blossom_tree/)

[【学习笔记】一般图最大匹配(带花树) | 𝓞𝓻𝓬𝓱𝓲𝓭𝓪𝓷𝔂'𝔀 𝓫𝓵𝓸𝓰](https://orchidany.gitee.io/2020/05/11/带花树/)

[【学习小记】一般图最大匹配——带花树算法 - BAJim_H - 博客园](https://www.cnblogs.com/BAJimH/p/10569418.html)

[Tutorial Blossom Algorithm for General Matching in O(n^3) - Codeforces](https://codeforces.com/blog/entry/92339)

[二分图最大权匹配 - OI Wiki](https://oi-wiki.org/graph/graph-matching/bigraph-weight-match/#hungarian-algorithmkuhnmunkres-algorithm)

有些地方直接看文字说明不好理解，可能结合代码会通畅一点。

### 网络流

[二分图与网络流 学习笔记](https://www.xht37.com/二分图与网络流-学习笔记/)

#### 费用流

[基于 Capacity Scaling 的弱多项式复杂度最小费用流算法 - ouuan](https://ouuan.github.io/post/基于-capacity-scaling-的弱多项式复杂度最小费用流算法/)

#### 最大权闭合子图

[最大权闭合子图 学习笔记 | linkfqy's Blog](https://linkfqy.github.io/posts/Maximum_Weight_Closure_of_a_Graph/)

问题：对于所有边 (u, v)，点 u 在子图中则 点v 必在子图中，求子图的点权和最大值。
$$
&w_i > 0     &\Rightarrow &add(S, i, w_i) \\
&w_i < 0     &\Rightarrow &add(i, T, -w_i) \\
&原图边(u, v) &\Rightarrow &add(u, v, INF)
$$
闭合子图和 $S$ 构成 集合 $V_S$，其余点和 $T$ 构成 集合 $V_T$。

最大权闭合子图的权 $W = \sum_{i \in V_S} w_i[w_i>0] - \sum_{i \in V_S} \abs{w_i}[w_i<0]$；

最小割一定是简单割，最小割的值为 $c(S, T) = \sum_{i \in V_T} w_i[w_i>0] + \sum_{i \in V_S} \abs{w_i}[w_i<0]$；

则点权和最大值 $W = \sum w_i[w_i>0] - c(S, T)$，即`正权点之和 - 最小割`。

不要被限制关系迷惑了，如[vjudge - 植物大战僵尸](https://vjudge.net/problem/%E6%B4%9B%E8%B0%B7-P2805)，限制关系，其实反过来考虑就是闭合子图。

直接上这种建图方式即可。注意排除一些题中一些性质不合法的情况，如上题就不能有环或被环连出的边。

总是转化为`选 a 必须选 b 的形式`，如[vjudge - 寿司餐厅](https://vjudge.net/problem/洛谷-P3749)，题意就很麻烦，但可以转化来着，还需要熟练的连边方式和算边数的能力。

### 2-SAT

[2-SAT - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/2-sat/)

[2-SAT速成 - 自为风月马前卒 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zwfymqz/p/8485365.html)

[2-SAT Tutorial - Codeforces](https://codeforces.com/blog/entry/16205)

2-SAT 的图具有对称性。

### 优化连边

[常见优化建图技巧](https://www.luogu.com.cn/blog/221955/chang-jian-you-hua-jian-tu-ji-qiao)

[各种优化建图 - qAlex_Weiq](https://www.cnblogs.com/alex-wei/p/Graph_connection_optimization.html)

#### 线段树优化连边

[Diu の blog](https://www.luogu.com.cn/blog/diu/solution-p6348)

把出点和入点放在线段树上，线段树内为了实现正常的点边关系（指到了这个点就可以从这个点出发等等）边权为 0，把要加的边加进去，区间到区间的，如果不加虚拟点，复杂度为 $O(log^{2}n)$，加了之后为 $O(logn)$。

出树从子节点向父节点连边，入树从父节点向子节点连边，共享（在线段树的叶子节点下面连原始点）。

原始点从出树出去，从入树回来；整体就是一个“回流”的过程。

原图上的边，连到虚拟点。（入边/出边加权或选择最后答案除二）

按照需求看需要建几棵线段树。

#### 树上优化建边

##### 树链剖分

配合线段树，和上方思想一致，按照需求看要建一棵还是两棵线段树。

注意在线段树里的下标代表树链剖分内部的 dfn。

一般建法需要 $log^2n$ 条边。

[「BZOJ 4699」树上的最短路（最短路 + 树链剖分 + 线段树） | blunt_axe](https://blunt-axe.github.io/2019/06/26/20190626-BZOJ4699-Shortest-Path/)

使用重链的前缀优化可以只建 $logn$ 条边，原理是往上跳的过程中只有最后一段可能跳的不是重链的前缀。

具体前缀优化建边方式为：

对于每一个点，我们拆出一个虚点，原点向虚点连长度为 0 的边，然后每个虚点向下一个虚点连长度为 0 的边。这样在前缀对应的最后一个点向外连边就等价于在原图上对于前缀上的所有点连出一条边了。

##### 倍增

倍增的同时，连边。和线段树类似的很容易在倍增数组上，连出这样的内部/外部边。



### 生成树

Kruskal, Prim

####  Boruvka

每一轮每个连通块独立去寻找到另一个连通块的最短边，选择这条边，如此迭代至多 $\log n$ 轮。

最短的边可能会是同一条边，所以并不会成环；且最坏情况下，两两配对，就是 $\log n$ 次。

[CF 888G](https://codeforces.com/problemset/problem/888/G) / [ICPC 2020 澳门 C](https://codeforces.com/gym/103119/problem/C)

因为相邻最近的异或和是小的，所以可以直接从深到浅去合并，只利用 Boruvka 的思想。

或者模拟各个连通块找最短边的过程。前者实现可以看 [orzdevinwang](https://codeforces.com/contest/888/submission/99615036) 后者实现可以看 [Qingyu](https://codeforces.com/contest/888/submission/94127770) 的。

还有直接分治的，[jiangly](https://codeforces.com/contest/888/submission/68431071) 。



## 数据结构

### 分块

[「分块」数列分块入门1 – 9 by hzwer - 分块](http://hzwer.com/8053.html)

[数列分块总结——题目总版（hzwer分块九题及其他题目）（分块） - Flash_Hu - 博客园](https://www.cnblogs.com/flashhu/p/8437062.html)

[浅谈区间众数 - 一铭君一 - 博客园](https://www.cnblogs.com/zaza-zt/p/15000395.html)

[莫队套值域分块 - 一铭君一 - 博客园](https://www.cnblogs.com/zaza-zt/p/15041167.html)

[【OI】值域分块入门 - ChiFAN鸭 - 博客园](https://www.cnblogs.com/chifan-duck/p/17060540.html)

[【知识总结】分块和值域分块_Cutele_的博客-CSDN博客](https://blog.csdn.net/weixin_45675097/article/details/119709367)

分析主要分为两部分：不完整的块、整块、预处理/维护（又分为数据的性质，单个数据的标记，如排序，统计是否为0，元素和 ...）...

比如，统计大于/小于的个数，就可以采用维护排序的做法，然后维护时可以用各种各样的数据结构。

因为很多时候还是要保持有原来的序列，所以常常要另外为每一块开一个数组。

选取的块的大小，可能因为和数据有关，就比较玄学（bushi），具体调参，可以生成大数据，然后用两个设定不同的对拍，看运行时间。

带插入的，用重新分块的操作，既可以在一块过大，也可以在$\sqrt{n}$次插入后重新分块等。

有时候还需要把块区间预处理出一些数据，复杂度一般为$O(块多少 \cdot n)$。

多个标记需要想清楚更新的先后顺序。

这边也贴一下[我的分块九题code](https://livinfly.top/186&decompose_9problems_for_beginner)好了。虽然第三题std有点锅，直接`set.erase`掉，它这一个数就全删了，但还是orz hzwer学长。



后几篇是讲区间众数、值域分块、莫队相关，也是由hzwer学长的第九题引出的。

### 线段树

#### 线段树分治

[线段树分治总结（线段树分治，线段树，并查集，树的dfn序，二分图染色） - Flash_Hu - 博客园 ](https://www.cnblogs.com/flashhu/p/9404225.html)

第一篇文章是线段树分治和并查集的结合，其实还可以和很多其他做结合。

第一篇文章里面给的第二道题目不用维护高度也行，可能不开 $O_2$ 的情况不好过（？），总之可以不这么在意。

大致思路就是把不好做的删除操作用栈存下来撤回。

由于本质是跑了一遍 dfs 序，所以甚至可以不用显式的建出线段树。

#### 吉如一（吉司机）线段树（seg-beats）

[区间最值操作与历史最值问题](http://www.doc88.com/p-6744902151779.html)

[区间最值操作与区间历史最值详解](https://www.luogu.com.cn/blog/Hakurei-Reimu/seg-beats)

[《区间最值操作与历史最值问题》 - 学习笔记 - p_b_p_b](https://www.cnblogs.com/p-b-p-b/p/14632059.html)

线段树通过维护一些信息达成维护**区间最值操作**和**历史最值**的性质。

把**区间最值操作**转成**区间加减**貌似是写起来更好写（？）。

复杂度证明思想用到势能，可能也可以归于势能线段树（？）。

势能线段树，还有**与**，**开根**等等，只修改区间势能不为零的区间，一次修改的复杂度大多为$O(logn)$或$O(log^2n)$。

具体可以势能分析法证。下面有些题目。

[势能线段树（吉司机线段树）专题](https://blog.csdn.net/jibinquan/article/details/120597782)

#### 李超线段树

[浅谈李超线段树 | cmwqf's blog](https://cmwqf.github.io/2020/05/18/浅谈李超线段树/)

选这篇主要是码风结构和我的写法比较像，参照的写比较容易。

### Kruskal重构树

[Kruskal重构树 - OIerC - 博客园](https://www.cnblogs.com/ACMSN/p/10646306.html)

[学习笔记：Kruscal 重构树 - DMoRanSky - 博客园](https://www.cnblogs.com/dmoransky/p/13812147.html)

图很棒，看图就很容易理解了。

（现在的理解）是用来求两个点之间经过的最大/最小路径的最小/最大值，转化为两点的LCA。

以求最大值的最小值为例，整个重构的过程，可以想我们的目标是把答案放在LCA，那么就是从小到大枚举边权，然后小的先合并，之后都用DSU的祖先来整体来看，也就是想要跨越这两个集合，一定要经过新加进来的边（因为比他小的边连完后，这两个集合仍然独立）。

重构树更多是一种思想，比如[Problem - F - Codeforces](https://codeforces.com/contest/1797/problem/F)就是重构树，思路类似于Kruskal重构树，但是可以不把另外的点建出来。

### 杂

[浅谈 OI 中的数据结构题 - DPairの博客 - 洛谷博客](https://www.luogu.com.cn/blog/DPair2005/qian-tan-shuo-ju-jie-gou-ti-zai-oi-zhong-di-ying-yong)

#### 二维数点 / 二维偏序

[二维数点技巧 - ZCETHAN - 博客园](https://www.cnblogs.com/ZCETHAN/p/16573991.html)

思想来自扫描线（在本文计算几何章节）。

大概是枚举一维（扫描一维），然后数据结构弄另一维。

一般是离线的，在线加可持久化可以解决（我还没写过）。

upd:

偏序算在点的左下角区域的点是好做的，只要一维排序，另一维数据结构，然后查询比要求的点低的点数就行。

求矩阵的话，需要离线下来，把查询拆成几部分（两部分一般），然后加加减减。

[SHOI2007 园丁的烦恼](https://www.luogu.com.cn/problem/P2163)

#### 珂朵莉树/老司机树（ODT）

[珂朵莉树模板CF896C Willem, Chtholly and Seniorious题解 - 泥土笨笨](https://www.luogu.com.cn/blog/nitubenben/solution-cf896c)

[珂朵莉树的复杂度分析](https://zhuanlan.zhihu.com/p/102786071)

[浅谈珂朵莉树 - DPairの博客](https://www.luogu.com.cn/blog/DPair2005/qian-tan-ke-duo-li-shu)

随机数据条件下，时间复杂度十分的香啊。

就是暴力啦。

## 字符串

周期可以非完整，循环节是完整的。

求周期 等价于 求 border，s[i] =s[i+|s|-|p|]，就是周期。

border 不具有二分性。（不同的题目，Border 是否包含自己不一定）

Base > |字符数|

最好：Mod >= Base^2

周期定理：若 p, q 均为 S 的周期，则 (p, q) (gcd) 也为 S 的周期。

一个串的 border 数量为 O(N) 个，但他们组成 O(logN) 个等差数列。

### 哈希

// 列点好用的哈希模数（~~1031252627~~

### Trie 树

删除，先找到，然后递归往回删，到有别的点也要用的地方停，删终止标记。

（或者用持久化，即减小 cnt 的方式删掉，实现上更方便）

本质可以和字典序大小联系。

区间异或和最大 -> Trie树上前缀异或和。

数组大小应为，点数 × 层数（长度），然后第二维是看可能的分支数量。

查询和插入的函数参数，可以加上 root 和 dep，且查询的时候，建议把值过程中计累计 (1<<i) 算。这样可以方便在分治或者别的情况下，不重新建一棵 trie 树。

#### 可持久化

持久化 01-Trie，可持久化维护 cnt[u] （在 u 的子树中的终止节点个数，判断节点是否真实存在）。

### Border 树 （next 树，失配树，KMP 自动机）

求 next 数组，i 向 next[i] 连边，构成 n+1 个节点的树。

性质：

1.   每个前缀 Prefix[i] 的所有 Border： i 节点到根的链。
2.   有哪些前缀有长度为 x 的 Border： x 的子树。
3.   求两个前缀的公共 Border： 求 LCA。

### AC 自动机（ACAM）

给出一个字典，询问有多少字典串在询问串中出现过，即单串和多串的匹配问题。

AM 自动机 = Trie（前缀信息） + KMP（后缀信息fail链）， 是离线型数据结构，不支持增量添加字符串。

用于字符串询问类的离线处理，和 DP 结合或补成 Trie 图。

复杂度线性（Trie 字符串总长度×字符集大小 + fail O(n)），势能总量为 Trie 节点数总数。

建 Trie 树，BFS 遍历，到一个点，看它父节点的 fail 链，依次看 fail 链的点指向的子节点，有没有等于当前节点的值，有就指向那个等于当前节点值的点。（原始不带优化的AC自动机版本）

几个常数优化：

1.   fail 优化

     ```cpp
     // 减少跳 fail
     // 在 build 时，从暴力跳 fail 找，变为 O(1) 赋值
     fail[v] = tr[fail[u]][z] // z 为下一个字母
     ```

2.   Trie 图优化

     ```cpp
     // 减少跳 fail，考虑到跳完 fail 是为了继续扩展的情况
     // 从没有对应子节点，跳 fail 去寻找下一个节点，到直接连接对应的节点
     // 从 Trie 树变成了 Trie 图
     // 但好像由于已经进行了 fail 优化，Trie图优化，感觉只是写起来方便了点（？？？）
     tr[u][z] = tr[fail[u]][z]; // z 为下一个字母；在没有对应子节点时
     ```

3.   last 优化

     ```cpp
     // 减少跳 fail，用于（暴力）计数处理，从跳 fail 改为跳 last ，但实际上直接在 fail 树（记下入度就行）上bfs求和是不是就已经准确 O(n) 了
     // 感觉不是很有必要。黏一下别人的代码
     // build 时
     last[c]=end[fail[c]]?fail[c]:last[fail[c]];
     // 匹配时
     void count(int x) {
         while(x) {
            //计数、打印等，视题目要求顶
             x = last[x];
         }
     }
     void match() {
         int now = 1;
         for(int i=1;s[i]!='\0';++i) {
             int x = s[i]-'a';
             now = ch[now][x];
             if(end[now]) count(now);
             else if(last[now]) count(last[now]);
         }
     }
     ```

     

#### Trie 图

AC 自动机加强版。





### 回文串

固定回文中心，二分回文半径。

#### Manacher（马拉车）

[Manacher - OI Wiki](https://oi-wiki.org/string/manacher)



## 动态规划

### 常见模型（？）

子序列 -> 线性

### 高维前缀和/子集和DP (SOS DP, sum over subset)

[SOS Dynamic Programming Codeforces](https://codeforces.com/blog/entry/45223)

[Tutorial on Zeta Transform, Mobius Transform and Subset Sum Convolution - Codeforces](https://codeforces.com/blog/entry/72488)

[集合幂级数相关 - qAlex_Weiq - 博客园](https://www.cnblogs.com/alex-wei/p/set_power_series.html)

这部分好像思想与`FMT/FWT`比较类似，那边的文章也可以看看。

多维独立的信息，分步再整合的感觉。

### 树上背包

[树上背包的上下界优化 - ouuan](https://www.cnblogs.com/ouuan/p/BackpackOnTree.html)

[子树合并背包类型的dp的复杂度证明_背包型树形dp 复杂度_cervoliu的博客-CSDN博客](https://blog.csdn.net/lyd_7_29/article/details/79854245)

LCA是通俗易懂的复杂度估计。

## 数学

### 线性基

[关于线性基的学习与理解 - ljh_2000 - 博客园](https://www.cnblogs.com/ljh2000-jump/p/5869991.html)

[线性基学习笔记 | Menci's OI Blog](https://oi.men.ci/linear-basis-notes/)

与线代相关，但知道基底也就比较好理解， 来求**子集最大异或和**等问题，分为贪心和高斯消元两种求法，oi-wiki上说高斯消元法有的，贪心法没有的性质，可以在贪心的求完后，用比自己低位的消掉`1`获得一样的效果。感觉merci大佬的写法很好qwq（当然也可以先插入然后再统一消除）



### FFT/NTT

[FFT/NTT 多项式学习笔记 - Fenghr - 博客园](https://www.cnblogs.com/fenghaoran/p/7107608.html)

[FFT\NTT总结 - Cyhlnj - 博客园](https://www.cnblogs.com/cjoieryl/p/8206721.html)

[NTT&FFT 快速？变换,以及扩展 - chasedeath - 博客园](https://www.cnblogs.com/chasedeath/p/12070229.html)

因为**系数表达式**相乘不方便，而**点值表达式**相乘，直接点值的函数值相乘就行，所以用**FFT**把**系数表达式**转化为**点值表达式**，相乘后，再用**IFFT**（**FFT**的逆操作）变回**系数表达式**。推导看下来大概就会明白**FFT**和**IFFT**的联系，然后复数运算常数比较大，自己实现下这个类比较好。



### FMT/FWT

[集合幂级数相关 - qAlex_Weiq - 博客园](https://www.cnblogs.com/alex-wei/p/set_power_series.html)

[位运算卷积(FWT) & 集合幂级数 - command_block 的博客 - 洛谷博客 (luogu.com.cn)](https://www.luogu.com.cn/blog/command-block/wei-yun-suan-juan-ji-yu-ji-kuo-zhan)

[快速沃尔什变换 - OI Wiki](https://oi-wiki.org/math/poly/fwt/)

[快速沃尔什变换/FWT 详详详解_Hypoc_的博客-CSDN博客](https://blog.csdn.net/a_forever_dream/article/details/105110089)

[快速变换之Fast Mobius Transform - 知乎](https://zhuanlan.zhihu.com/p/524186131)

[快速莫比乌斯变换 / Fast Mobius Transform, FMT - AE酱 - 博客园](https://www.cnblogs.com/AEMShana/p/13488014.html)

[快速沃尔什变换及快速莫比乌斯变换学习笔记 | Bill Yang's Blog](http://blog.bill.moe/fast-walsh-transform-notes/)



### 博弈论

#### 二分图博弈模型

[算法学习笔记(74): 二分图博弈 - Pecco](https://zhuanlan.zhihu.com/p/359334008)

[【蒟蒻数学】巧妙运用二分图解决博弈论 - 蒟蒻のBLOG (jvruo.com)](https://www.jvruo.com/archives/408/)

[【学习笔记】二分图博弈证明 - 残城三梦](https://livinfly.top/198&bi-graph_game)

#### 树上博弈

[树上博弈 - sora_013](https://www.cnblogs.com/sora-13/p/15149895.html)



### 生成函数

[Tutorial\] Generating Functions in Competitive Programming - Part 1 - Codeforces](https://codeforces.com/blog/entry/77468) 

[Tutorial\] Generating Functions in Competitive Programming - Part 2 - Codeforces](https://codeforces.com/blog/entry/77551) 



## 计算几何

[计算几何部分简介 - OI Wiki](https://oi-wiki.org/geometry/)

[dls的计算几何板子 - 知乎](https://zhuanlan.zhihu.com/p/625081715)

### 点在多边形内部

[详谈判断点在多边形内的七种方法 - CSDN](https://blog.csdn.net/WilliamSun0122/article/details/77994526)

一般多边形是O(n)，凸多边形可以二分logn



做法上，除了确定是凸多边形且有按照一定顺序排列的是可以logn确定是否在区域内，

一般的多边形，如果是普通多边形，射线法和转角法一致，而非一般的复杂多边形，两者对多边形区域的判定是有区别的。

如[GIS算法基础（二）计算几何基础（中） - 小钟233 - 博客园](https://www.cnblogs.com/zhongHW/p/11047021.html)中提到的例子（我做对横坐标和纵坐标都做了-3的偏移。

``` 
Input:
7
0 6
6 0
15 15
9 15
18 0
24 6
12 27
1
12 12

Output:
OUT - 射线法
IN  - 转角法
```

### 扫描线

[扫描线 - OI Wiki](https://oi-wiki.org/geometry/scanning)

[【学习笔记】扫描线 - NCC-79601 Captain's Log - 洛谷博客](https://ncc79601.blog.luogu.org/scan-line)

[扫描线求周长并 - kongbursi - 博客园](https://www.cnblogs.com/kongbursi-2292702937/p/12851399.html)

扫描过程通过OI Wiki来看。

面积的并，第二篇博客讲得很详细。用线段树维护`当前高度被覆盖的区间的总长度`与`当前区间被覆盖的次数`。由于是独立的矩形且是覆盖关系，所以每个区间的信息是独立的，所以不需要在小区间修改的时候，不需要把父区间的信息`pushDown`。

周长的并，第三篇博客分析得很清楚，第二篇较简略。

第一种是横向、纵向分别求。此时，每次操作对高度的贡献就是`操作前状态和操作后状态的长度改变量`，此时涉及同一高度的线段要`先加后减`的问题，因为我们用绝对值取改变量，如果每次操作后就加上此操作的贡献，会导致加上不存在的线段两倍，在排序的时候先加即可避免出现`不存在的空缺`；或者，同一高度的线段全都操作完，再计算当前高度的总贡献应该就没有这个问题，但是实现上显然没有上面直接求方便。

第二种，在一个方向上和第一种的其中一次一样。一个方向的解决了。我们考虑另一个方向的（假定是纵向的），首先是每一根的长度，显然是两次操作的高度差；那么有多少个这样的长度呢？想到这样的线是从低到高连过来的（假定从低到高操作），那么就当前高度的`独立段数*2`，每一段都是从下面的两根线段围起来的。最终就有这两篇博客中的结果。

### 求凸包

[数论小白都能看懂的平面凸包详解 - ShineEternal的笔记小屋 - 洛谷博客](https://www.luogu.com.cn/blog/ShineEternal/convex-hull)



## 思维

### Meet in the Middle

[Meet in the middle算法总结 - birchtree - 博客园](https://www.cnblogs.com/birchtree/p/10133392.html)

之前学过双向广搜，其实就是这个思想。

```cpp
若为 闭区间
dfs(0, n/2-1, 0, ans1);
dfs(n/2, n-1, 0, ans2);
/**********或者************/
dfs(1, n/2, 0, ans1);
dfs(n/2+1, n, 0, ans2);
/* 不然会造成RE/MLE等情况，因为不是一半分
	就记忆下面的这种就行，上面是都-1。 */
```



### DSU On Tree

[树上启发式合并 - OI Wiki](https://oi-wiki.org/graph/dsu-on-tree/)

[dsu on tree](https://www.cnblogs.com/zwfymqz/p/9683124.html)

[Tutorial Sack/dsu on tree - Codeforces](https://codeforces.com/blog/entry/44351)

主要是启发式合并的思想，这几篇文章提到的基本上还是轻重链的形式。[Problem - E - Codeforces](https://codeforces.com/contest/1825/problem/E)，这一题也是启发式合并，但不是轻重链，而是把要维护的信息用map来维护，合并的时候是启发式合并的思想。所以，主要是启发式合并的思想。

这种形式，我的理解是：

​	对每个子树来说，是对大的部分（重儿子）保留，轻儿子暴力求，有点把轻儿子合到重儿子的意味。然后，对于当前子树是重儿子的链，在后面被当作轻儿子时，一样要清空暴力求，来保证结果的正确性。从单个子树来看，它每棵子树都是从轻儿子开始求，然后撤除轻儿子的答案，来避免影响之后求重儿子，而重儿子因为是最后一个求，就保留只跑一遍，可以传递回父节点的值。

关于时间复杂度第二篇文章比较清楚，就不再反复论证了。



### 莫队

[普通莫队算法 - OI Wiki](https://oi-wiki.org/misc/mo-algo/)

[莫队详解 - JSOI爆零珂学家yzhang - 博客园](https://www.cnblogs.com/yzhang-rp-inf/p/9991671.html)

[莫队算法——从入门到黑题 - WAMonster - 博客园](https://www.cnblogs.com/WAMonster/p/10118934.html)

[莫队细讲——从零开始学莫队 - Hastieyua - 博客园](https://www.cnblogs.com/hyfhaha/p/12936009.html)

[莫队算法 / Mo's Algorithm - 知乎](https://zhuanlan.zhihu.com/p/25017840)

[静态莫队分块 - 一铭君一 - 博客园](https://www.cnblogs.com/zaza-zt/p/14979757.html)

[带修莫队分块 - 一铭君一 - 博客园](https://www.cnblogs.com/zaza-zt/p/14990713.html)

[回滚莫队分块 - 一铭君一 - 博客园](https://www.cnblogs.com/zaza-zt/p/14995497.html)

开始的几篇文章哪一篇好像都可以一篇全吃（

莫队是对询问优化，尽量运用给前一次提问的信息来更新下一次提问的答案。

让左右双指针走的“步数”尽量相近。

### 容斥

[容斥原理 - OI Wiki](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)

虽然思想很简单，但是很多时候就忘了。

常伴随正难则反的想法。

### cdq分治

[CDQ分治总结（CDQ，树状数组，归并排序） - Flash_Hu - 博客园](https://www.cnblogs.com/flashhu/p/9381075.html)

[abc309_F - Box in Box](https://atcoder.jp/contests/abc309/tasks/abc309_f)

三维信息，模板题的非严格比较需要去重。

第一维，现在外部排序，需要在cdq分治内的归并过程中满足两段性质；

第二维是在归并过程中排序；

第三维一般是用数据结构（常常是树状数组/线段树）维护并查询。

## 其他

[时间复杂度-势能分析浅谈 - Atalod](https://www.luogu.com.cn/blog/Atalod/shi-jian-fu-za-du-shi-neng-fen-xi-qian-tan)

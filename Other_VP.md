## 2023.5

### XJTUPC2023

前六题都确实是签到题（

H，也比较签到，稍微想想可以发现必须要有一种字符在所有字符串里出现的次数各不相同，充要很容易证明。

K，好像他们赛时没怎么出这道题，就是一条 1 到 n 的路径，然后再有路径上两个点`x, y`从不通过原本的路径，的路径的和，即`d[1][x] + d[x][y] + dd[x][y] + d[y][n]`，这里dd是次短路。

因为是有向无环图，次短路，要么先跑拓扑排序，然后bfs，要么dijkstra来跑，更新的时候，拿u的最短路、次短路分别来试着更新v的最短路和次短路。

~~后面不太想思考，补~~

G，贪心是对的，但是证明贪心的话可能得找找论文（？），出题人还有一种构造的方式。

J，因为最近学了莫队，先用官方题解的莫队做法补了，考虑怎么在一次修改维护住答案，所以需要在最终答案的基础上，多维护在左端修改时需要的$\sum_{i = l}^{r} ans[l, i]$，右端需要维护$\sum_{i = l}^{r} ans[i, r]$，发现这两个信息并不难维护，然后就可以做了。

O，不懂啊，感觉是出现过的编号*(n-1)! ？但是是n!

N，若序列不连续，那一定是用栈模式；若序列连续，一定是用队列模式。考虑一下，栈模式一定会让数插入和删除的次数是最小的，但是会在连续的情况下比队列多一个转变模式的消费。

M，~~因为我写搜索写的太少了，这种写法看了题解还是不太会呢（~~，返回值是子树`PII`，变成斑马子树和变成纯黑子树的时间点，然后在每次搜完，每个子树在以操作时间为下标的差分数组，在`l`处`+1`，`r`处`-1`。最后在差分数组做前缀和就可以求出每个时间的斑马子树个数。

第二种做法就是求它的补集，纯白和纯黑的个数。